---
title: "**{shorts}**: An R Package for Modeling Short Sprints"
date: "`r Sys.Date()`"
author: 
  - Mladen JovanoviÄ‡^[Faculty of Sport and Physical Education, University of Belgrade, Serbia, coach.mladen.jovanovic@gmail.com]
  - Jason D. Vescovi^[Faculty of Kinesiology and Physical Education, Graduate School of Exercise Science, Toronto, ON Canada, vescovij@gmail.com]
abstract: >
  Short sprint performance is one of the sport's most distinguishable and admired physical traits. Short sprints have been modeled using the mono-exponential equation that involves two parameters: (1) maximum sprinting speed (MSS) and (2) relative acceleration (TAU). The most common methods to assess short sprint performance are radar guns or timing gates. In this paper, we: 1) provide the **{shorts}** package that can model sprint timing data from these two sources; 2) discuss potential issues with assessing sprint time (synchronization and flying start, respectively); and 3) provide model definitions within the **{shorts}** package to help alleviate errors within the subsequent parameter outcomes.
citation_package: natbib
bibliography: [references.bib, packages.bib]
output:
  bookdown::word_document2:
    number_sections: FALSE
link-citations: yes
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
require(knitr)
require(shorts)
require(tidyverse)
require(bookdown)

my_random_seed <- 1667
set.seed(my_random_seed)

def.chunk.hook <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size != "normalsize", paste0("\n \\", options$size, "\n\n", x, "\n\n \\normalsize"), x)
})

knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  fig.retina = 0.8, # figures are either vectors or 300 dpi diagrams
  dpi = 600,
  out.width = "90%",
  fig.align = "center",
  fig.width = 5,
  fig.height = 5 * 0.618, # 1 / phi
  fig.show = "hold",
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  width = 65,
  size = "small"
)

# automatically create a bib database for R packages
# knitr::write_bib(c(
#  .packages(), "bookdown", "knitr", "rmarkdown", "shorts", "LambertW", "kableExtra", #"minpack.lm"
# ), "packages.bib")


# Set rounding
op <- options()

options(
  digits = 3,
  "width" = 65,
  scipen = 999,
  knitr.kable.NA = ""
)
```

# Introduction

Short sprint performance is one of the sport's most distinguishable and admired physical traits. Short sprints, commonly performed in most team sports (e.g., soccer, field hockey, handball, football, etc.), are defined as maximal running from a stand-still position over a distance that does not result in deceleration at the end. Peak anaerobic power is achieved within the first few seconds (<5 $s$) of maximal efforts [@mangineSpeedForcePower2014]. In contrast, achieving maximal sprint speed varies based on the athlete and sport. For example, track and field sprinters are trained to achieve maximal speed later in a race (i.e., 50-60 $m$) [@ward-smithEnergyConversionStrategies2001], but team sport athletes have sport-specific attributes and reach it much sooner (i.e., 30-40 $m$)[@brownAssessmentLinearSprinting2004]. Regardless of the differences in kinematics between athletes, evaluating short sprint performance is routinely included within a battery of fitness tests for a wide range of sports

The use of force plates is considered the gold standard for assessing the mechanical properties of sprinting; however, there are logistical and financial challenges to capturing the profile of an entire sprint [@morinSimpleMethodComputing2019; @samozinoSimpleMethodMeasuring2016]. Radar and laser technology are frequently used laboratory-grade methods [@buchheitMechanicalDeterminantsAcceleration2014; @edwardsSprintAccelerationCharacteristics2020; @jimenez-reyesRelationshipVerticalHorizontal2018; @marcote-pequenoAssociationForceVelocity2019] but are not ordinarily accessible to practitioners working in sports. Undoubtedly, the most common method available and used to evaluate sprint performance is the use of timing gates. Often multiple gates are positioned at varying distances to capture split times (e.g., 5, 10, 20 $m$), which can now be incorporated into the method for determining sprint mechanical properties [@morinSimpleMethodComputing2019; @samozinoSimpleMethodMeasuring2016]. This approach presents an advantage to practitioners using the outcomes to describe individual differences, quantify the effects of training interventions, and better understand performance limiting factors.

The **{shorts}** package [@R-shorts], written in the R language [@R-base], represents an open-source tool to help sports scientists translate raw timing data into detailed mechanical outcomes through mathematical modeling [@morinSimpleMethodComputing2019; @samozinoSimpleMethodMeasuring2016]. To the best of our knowledge, scientist, researchers, and coaches have been performing short sprints modeling using the built-in solver function of Microsoft Excel (Microsoft Corporation, Redmond, Washington, United States) [@morinSpreadsheetSprintAcceleration2017; @morinSpreadsheetSprintAcceleration2019; @stenrothForcevelocityProfilingIce2020; @stenrothSpreadsheetSprintAcceleration2020; @samozinoSimpleMethodMeasuring2016; @clarkNFLCombine40Yard2017; @morinSimpleMethodComputing2019], which makes the **{shorts}** package a major improvement in ease-of-use, speed, transparency, reproducibility, and more feature-rich model fitting. 

The current paper will explain one commonly used mathematical equation to model short sprints, modeling applications using the **{shorts}** package, issues arising during measurement and estimation, and potential solutions to those problems.

# Mathematical model

Short sprints have been modeled using the mono-exponential equation \@ref(eq:velocity-time), originally proposed by @doi:10.1098/rspb.1927.0035 and more recently popularized by @clarkNFLCombine40Yard2017 and @samozinoSimpleMethodMeasuring2016. Equation \@ref(eq:velocity-time) represents the function for instantaneous horizontal velocity $v$ given the time $t$ and two model parameters: 

\begin{equation}
  v(t) = MSS \times (1 - e^{-\frac{t}{TAU}}) (\#eq:velocity-time)
\end{equation}

The parameters of equation \@ref(eq:velocity-time) are *maximum sprinting speed* (MSS; expressed in $ms^{-1}$) and *relative acceleration* (TAU; expressed in $s$). Mathematically, TAU represents the ratio of MSS to initial acceleration (MAC; *maximal acceleration*, expressed in $ms^{-2}$) (equation \@ref(eq:maximal-acceleration)). Given the equation \@ref(eq:velocity-time), TAU can be interpreted as the time required to reach a sprinting velocity equal to `r round(100 * (1 - exp(-1)), 1)`% of MSS.

\begin{equation}
  MAC = \frac{MSS}{TAU}(\#eq:maximal-acceleration)
\end{equation}

Although TAU is used in the equations and later estimated, we prefer MAC since it is easier to grasp, particularly for less math-inclined coaches. 

By derivating equation \@ref(eq:velocity-time), we can get the equation for horizontal acceleration \@ref(eq:acceleration-time).

\begin{equation}
  a(t) = \frac{MSS}{TAU} \times e^{-\frac{t}{TAU}}  (\#eq:acceleration-time)
\end{equation}

By integrating equation \@ref(eq:velocity-time), we can get the equation for distance covered \@ref(eq:distance-time).

\begin{equation}
  d(t) = MSS \times (t + TAU \times e^{-\frac{t}{TAU}}) - MSS \times TAU  (\#eq:distance-time)
\end{equation}

Let us consider four athletes with different levels of MSS (high versus low maximal sprinting speed) and MAC (high versus low maximal acceleration; as mentioned previously, using MAC is preferred over using TAU):

```{r four-athletes-table, echo=FALSE}
athletes <- tribble(
  ~Athlete, ~MSS, ~MAC,
  "Athlete A", 12, 10,
  "Athlete B", 12, 6,
  "Athlete C", 8, 10,
  "Athlete D", 8, 6
)

athletes <- athletes %>%
  mutate(TAU = MSS / MAC)

knitr::kable(
  athletes,
  #caption = "Four athletes with different MSS and MAC parameters.",
  digits = 2,
  booktabs = TRUE
)
```

Next figure depicts distance, velocity, and acceleration over time (from 0 to 6 $s$):

```{r four-athletes-kinematics, echo=FALSE}
kinematics <- expand_grid(
  athletes,
  time = seq(0, 6, length.out = 1000)
) %>%
  mutate(
    distance = predict_distance_at_time(time, MSS, MAC),
    velocity = predict_velocity_at_time(time, MSS, MAC),
    acceleration = predict_acceleration_at_time(time, MSS, MAC)
  )

kinematics_long <- kinematics %>%
  pivot_longer(
    cols = c("distance", "velocity", "acceleration"),
    names_to = "variable"
  ) %>%
  mutate(
    variable = factor(
      variable,
      levels = c("distance", "velocity", "acceleration"),
      labels = c(
        expression("Distance (m" * ")"),
        expression("Velocity (ms"^-1 * ")"),
        expression("Acceleration (ms"^-2 * ")")
      )
    )
  )

gg <- ggplot(
  kinematics_long,
  aes(x = time, y = value, color = Athlete)
) +
  theme_bw(8) +
  geom_line(alpha = 0.7) +
  facet_wrap(
    ~variable,
    scales = "free_y",
    labeller = label_parsed
  ) +
  ylab(NULL) +
  xlab("Time (s)") +
  theme(
    legend.position = "top",
    legend.title = element_blank()
  )

plot(gg)
```

Plotting acceleration against velocity in the next figure, we will get the *Acceleration-Velocity Profile*, which is linear, according to the mathematical model. If the athlete's body mass (kg) is known, as well as additional air resistance parameters (see [Air resistance and the calculation of force and mechanical power] section of this paper), *Force-Velocity Profile* can be estimated (see [Force-Velocity profile] section of this paper). 

```{r four-athletes-profile, echo=FALSE}
gg <- ggplot(
  kinematics,
  aes(x = velocity, y = acceleration, color = Athlete)
) +
  theme_bw(8) +
  geom_line(alpha = 0.7) +
  ylab(expression("Acceleration (ms"^-2 * ")")) +
  xlab(expression("Velocity (ms"^-1 * ")")) +
  xlim(c(0, 12)) +
  theme(
    legend.position = "top",
    legend.title = element_blank()
  )

plot(gg)
```

# Estimation using **{shorts}** package

Short sprints profiling is usually performed by: (1) measuring split times using timing gates (i.e., positioned at various distances, e.g., 5, 10, 20, 30, 40 $m$), or (2) getting a velocity trace using a radar gun. Estimation of MSS and TAU parameters from equation \@ref(eq:velocity-time) is performed in **{shorts}** package for the **R language** [@R-base] using *non-linear least squares regression* implemented in the `nlsLM()` function from the **{minpack.lm}** package [@R-minpack.lm].

## Estimating short sprint parameters using timing gates split times

For timing gates split times, distance is a predictor, and time is the outcome variable. Thus, equation \@ref(eq:distance-time) becomes:

\begin{equation}
  t(d) = TAU \times W(-e^{\frac{-d}{MSS \times TAU}} - 1) + \frac{d}{MSS} + TAU (\#eq:time-distance)
\end{equation}

In equation \@ref(eq:time-distance), $W$ represents Lambert's W function [@R-LambertW]. Researchers often incorrectly use the equation \@ref(eq:distance-time) [@morinSpreadsheetSprintAcceleration2017; @morinSpreadsheetSprintAcceleration2019; @stenrothSpreadsheetSprintAcceleration2020], in which the time is the predictor and distance is the outcome variable, instead of the statistically correct equation \@ref(eq:time-distance). This practice should be avoided because switching the predictor and outcome variables in the regression model might produce biased estimated parameters [@motulskyIntuitiveBiostatisticsNonmathematical2018, p. 341]. These biases might not necessarily be significant with the short sprints profiling, but it is nevertheless a bad statistical practice.

Here is an example using a built-in dataset. We are going to filter out one athlete (e.g., John) with the help of the **{tidyverse}** [@R-tidyverse] package and estimate MSS, TAU, and MAC parameters using the `model_timing_gates()` function:

```{r}
require(shorts)
require(tidyverse)

# Load built-in dataset
data(split_times)

# Filter timing gates splits for John
john_TG_data <- split_times %>%
  filter(athlete == "John")

john_TG_data

# Estimate John's MSS, TAU, MAC, and PMAX
m1 <- model_timing_gates(
  distance = john_TG_data$distance,
  time = john_TG_data$time
)

m1
```

Maximal relative power (PMAX) from the output is estimated using $\frac{MSS \times MAC}{4}$, disregarding the air resistance.

Besides providing *residual standard error* (RSE), **{shorts}** functions provide additional model fit estimators. Additional information can be gained by exploring the returned object, particularly the object returned from the `nlsLM()` function (i.e., by using the S3 `summary()` method). To extract estimated model parameters, use S3 `coef()` method. 

To create a simple plot of the model, use the S3 `plot()` method, which returns **{ggplot2}** [@R-ggplot2] object:

```{r}
plot(m1) + theme_bw(8)
```

Once we have estimated MSS and MAC, we can use `predict_XXX()` family of functions to predict various relationships (i.e., time at distance, acceleration at distance, velocity at time, etc.):

```{r}
# Predict time at distance
predict_time_at_distance(
  distance = john_TG_data$distance,
  MSS = m1$parameters$MSS,
  MAC = m1$parameters$MAC
)
```

## Estimating short sprint parameters using the radar gun

Estimating the short sprint profile using radar gun data takes time as a predictor and velocity as the outcome variable. Estimation using radar gun data is implemented in the **{shorts}** package using `model_radar_gun()` function.

Here is an example using built-in dataset:

```{r}
# Load built-in dataset
data(radar_gun_data)

# Filter radar gun data for John
john_RG_data <- radar_gun_data %>%
  filter(athlete == "John")

head(john_RG_data)

# Estimate John's MSS, TAU, MAC, and PMAX
m2 <- model_radar_gun(
  velocity = john_RG_data$velocity,
  time = john_RG_data$time
)

m2
```

There is the additional parameter in the output, TC, that is estimated using the `model_radar_gun()` function. The function of this parameter is explained in the [Problems with time sync with the radar gun] section of this paper.

Both timing gates and radar gun models allow *weighted* non-linear regression. Weighting in regression is utilized when the observations have unequal error variance [@gelmanRegressionOtherStories2020], which can happen due to instrumental error (e.g., a multiplicative error instead of additive error) or due to biological variability (e.g., higher split time variance on shorter distances versus longer distances). In this case, observations with higher error variance get lower weight when fitting the model [@gelmanRegressionOtherStories2020]. According to @gelmanRegressionOtherStories2020, unequal variances are not typically a significant issue for the goal of estimating regression parameters, but they can become more important when making predictions about individual observations. Further exploring the topic of unequal error variances is beyond the scope of this paper. However, the **{shorts}** package provides a weighting feature for potential research of this topic in the future. 

Weighted non-linear regression is performed by setting the `weights` parameter. For example, we can give more weight to shorter distances or faster velocities:

```{r}
m2_weighted <- model_radar_gun(
  velocity = john_RG_data$velocity,
  time = john_RG_data$time,
  weights = 1 / (john_RG_data$velocity + 1)
)

m2_weighted
```

## Air resistance and the calculation of force and mechanical power

To estimate force production at distance or time (using `predict_force_at_distance()` and `predict_force_at_time()` functions), as well as power production (using `predict_power_at_distance()` and `predict_power_at_time()` functions), one needs to take into account the air resistance. Air resistance (measured in Newtons, $N$) is estimated using `get_air_resistance()` function, which takes velocity, body mass ($kg$), body height ($m$), barometric pressure ($Torr$), air temperature ($C^\circ$), and wind velocity ($ms^-1$) as parameters (please refer to @arsacModelingEnergetics100m2002, @samozinoSimpleMethodMeasuring2016, and @vaningenschenauCanCyclePower1991 for more information):

```{r}
get_air_resistance(
  velocity = 5,
  bodymass = 80,
  bodyheight = 1.85,
  barometric_pressure = 780,
  air_temperature = 20,
  wind_velocity = 0.5
)
```

When estimating force and power, the air resistance parameters can be set using `"..."`, which are forwarded to the `get_air_resistance()`:

```{r}
# To calculate horizontal force produced
predict_force_at_distance(
  distance = john_TG_data$distance,
  MSS = m1$parameters$MSS,
  MAC = m1$parameters$MAC,
  # Additional parameters forwarded to get_air_resistance
  # Otherwise, defaults are used
  bodymass = john_TG_data$bodyweight,
  bodyheight = 1.85,
  barometric_pressure = 780,
  air_temperature = 20,
  wind_velocity = 0.5
)
```

The easiest way to get all kinematics and kinetics for short sprints is to use `predict_kinematics()` function:

```{r}
df <- predict_kinematics(
  m1,
  max_time = 6,
  frequency = 100,
  # Additional parameters forwarded to get_air_resistance
  # Otherwise, defaults are used
  bodymass = john_TG_data$bodyweight[1],
  bodyheight = 1.85,
  barometric_pressure = 780,
  air_temperature = 20,
  wind_velocity = 0.5
)
```

Plotting the model predictions can be done once we convert data from wide to long with the help of **{ggplot2}** [@R-ggplot2], **{dplyr}** [@R-dplyr], and **{tidyr}** [@R-tidyr] packages (loaded already using the **{tidyverse}** [@R-tidyverse] package):

```{r}
variable_names <- colnames(df)

df <- pivot_longer(data = df, cols = -2) %>%
  mutate(name = factor(name, levels = variable_names))

ggplot(df, aes(x = distance, y = value)) +
  theme_bw(8) +
  facet_wrap(~name, scales = "free_y") +
  geom_line(alpha = 0.7) +
  ylab(NULL) +
  xlab("Distance (m)")
```

These kinematic and kinetic variables are utilized in [Force-Velocity profile] estimation, which is covered later in this paper. 

## Utility functions 

Another valuable addition for sports scientists and coaches is the ability to determine the distances and times where 90% of maximum sprinting speed is reached, or where peak power is within 90% range. To identify these values, the **{shorts}** package comes with the `find_XXX()` family of functions:

```{r}
# Finds distance where 90% of maximum sprinting speed is reached
find_velocity_critical_distance(
  MSS = m1$parameters$MSS,
  MAC = m1$parameters$MAC,
  percent = 0.9
)

# Finds maximal power and distance (this time using air resistance)
find_max_power_distance(
  MSS = m1$parameters$MSS,
  MAC = m1$parameters$MAC,
  # Additional parameters forwarded to get_air_resistance
  # Otherwise, defaults are used
  bodymass = 80,
  bodyheight = 1.85,
  barometric_pressure = 780,
  air_temperature = 20,
  wind_velocity = 0.5
)

# Finds distance over 90% power range
find_power_critical_distance(
  MSS = m1$parameters$MSS,
  MAC = m1$parameters$MAC,
  # Additional parameters forwarded to get_air_resistance
  # Otherwise, defaults are used
  bodymass = 80,
  bodyheight = 1.85,
  barometric_pressure = 780,
  air_temperature = 20,
  wind_velocity = 0.5
)
```

## Force-Velocity profile

To create *Force-Velocity Profile* (FVP) using single athlete estimated sprint model parameters (i.e., MSS and MAC), you can use the `make_FV_profile()` function. When estimating FVP, athlete body mass (kg) can be set using `bodymass` parameter, while the air resistance parameters can be set using `"..."`, which are forwarded to the `get_air_resistance()` function. Details of the FVP method implemented in the **{shorts}** package and the interpretation from a sprint training perspective are covered elsewhere [@haugenPowerForceVelocityProfilingSprinting2020; @morinInterpretingPowerForceVelocityProfiles2016; @morinSimpleMethodComputing2019; @samozinoSimpleMethodMeasuring2016]. 

```{r}
# To create Force-Velocity Profile
fvp <- make_FV_profile(
  MSS = m1$parameters$MSS,
  MAC = m1$parameters$MAC,
  bodymass = 80,
  # Additional parameters forwarded to get_air_resistance
  # Otherwise, defaults are used
  bodyheight = 1.85,
  barometric_pressure = 780,
  air_temperature = 20,
  wind_velocity = 0.5
)

fvp
```

To plot FVP kinematics and kinetics (which are the same as generated by the `predict_kinematics()` function), use the S3 `plot()` function. FVP estimated kinetics are default plotted against velocity (on the x-axis).

```{r results='hide', fig.show='hide'}
plot(fvp) + theme_bw(8)
```

To plot FVP estimated kinetics against time, use `type = "time"` parameter:

```{r results='hide', fig.show='hide'}
plot(fvp, "time") + theme_bw(8)
```

# Problems with estimation

There is a challenge when collecting sprint data that could substantially impact modeled outcomes. To ensure accurate parameter outcomes, the initial force production must be synced with the start time [@haugenPowerForceVelocityProfilingSprinting2020; @haugenSprintMechanicalVariables2019]. Below we describe this challenge when using radar guns or timing gates and suggest potential solutions within the **{shorts}** package.

## Problems with time sync with the radar gun

Time synchronization is one error in the modeled estimation using a radar gun. In theory, synchronization is ideal when a sprint is initiated at $t=0$ $s$ (i.e., $v(t=0) = 0$ $ms^-1$). In practice, this is often not the case. This might happen when the measurement starts before the sprint starts. Although these data should be *trimmed*, the time variable might not be synchronized perfectly (i.e., sprint starts exactly at $t=0$ $s$) with the sprint initiation afterward.  

The potential solution incorporated into the **{shorts}** package involves estimating the *time correction* (TC) parameter using equation \@ref(eq:velocity-time-correction). TC parameter serves as *intercept*, similar to linear regression, and allows the model to be fitted correctly in the scenario explained. 

\begin{equation}
  v(t) = MSS \times (1 - e^{-\frac{t + TC}{TAU}}) (\#eq:velocity-time-correction)
\end{equation}

This model is incorporated in the `model_radar_gun()` function (see [Estimating short sprint parameters using the radar gun]), and TC is estimated in addition to MSS, MAC, and TAU parameters.

## Problems at the start when using timing gates

Let us imagine we have two twin brothers with the same short sprint characteristics: MSS equal to 9 $ms^{-1}$ and MAC equal to 8 $ms^{-2}$. Let us call them John and Jack. They perform 40 $m$ sprints using timing gates set at 5, 10, 20, 30, and 40 $m$. The initial timing gate at the start (i.e., $d=0$ $m$) activates the timing system (i.e., when they cross the beam).

John represents the *theoretical model*, in which we assume that the initial force production and the timing initiation are perfectly synchronized. On the other hand, Jack represents a *practical model* and decides to move slightly behind the initial timing gate (i.e., for 0.5 $m$) and use body rocking to initiate the sprint start. In other words, Jack uses a *flying start*, a common scenario when testing field sports athletes. Flying start distance is often recommended to avoid premature timing system triggering by lifting knees or swinging arms [@altmannAccuracySingleBeam2018; @altmannDifferentStartingDistances2015; @altmannValiditySingleBeamTiming2017; @haugenPowerForceVelocityProfilingSprinting2020; @haugenSprintRunningPerformance2016]. 

Data for this scenario is generated using `create_timing_gates_splits()` function:

```{r}
split_times <- tibble(
  distance = c(5, 10, 20, 30, 40),
  john_time = create_timing_gates_splits(
    MSS = 9,
    MAC = 8,
    gates = distance
  ),
  jack_time = create_timing_gates_splits(
    MSS = 9,
    MAC = 8,
    gates = distance,
    FD = 0.5
  )
)
```

Here is a graphical representation of the sprint splits (please refer to the [Supplemental Material] for the R code):

```{r echo=FALSE}
plot_df <- split_times %>%
  select(distance, john_time, jack_time) %>%
  rename(John = john_time, Jack = jack_time) %>%
  pivot_longer(cols = -1, names_to = "athlete", values_to = "time") %>%
  mutate(distance = factor(distance))

ggplot(
  plot_df,
  aes(x = distance, y = time, color = athlete, group = athlete)
) +
  theme_bw(8) +
  geom_point() +
  geom_line() +
  xlab("Distance (m)") +
  ylab("Time (s)") +
  theme(
    legend.title = element_blank(),
    legend.position = "top"
  )
```

We can see the differences in estimated MSS and MAC parameters using the following code. For better table output, we are going to use the `kable()`function from the **{knitr}** package [@R-knitr].

```{r}
john_profile <- model_timing_gates(
  distance = split_times$distance,
  time = split_times$john_time
)

jack_profile <- model_timing_gates(
  distance = split_times$distance,
  time = split_times$jack_time
)

sprint_parameters <- rbind(
  coef(john_profile),
  coef(jack_profile)
)

rownames(sprint_parameters) <- c("John", "Jack")

kable(sprint_parameters, digits = 2, booktabs = TRUE)
```

As can be seen from the results, a flying start yields biased estimates, particularly for the TAU, MAC, and PMAX.

### Simple simulation

To explore this further, we have run a simple simulation by increasing Jack's flying start distance from 0 to 1 $m$ and depicting the estimated MSS, TAU, MAC, and PMAX parameters (please refer to the [Supplemental Material] for the R code).

```{r include=FALSE}
sim_df <- expand.grid(
  MSS = 9,
  MAC = 8,
  flying_start_distance = seq(0, 1, length.out = 1000),
  distance = c(5, 10, 20, 30, 40)
)

sim_df <- sim_df %>%
  mutate(
    TAU = MSS / MAC,
    PMAX = MSS * MAC / 4,
    time = create_timing_gates_splits(
      MSS = MSS,
      MAC = MAC,
      gates = distance,
      FD = flying_start_distance
    )
  )
```

```{r include=FALSE}
# Prediction wrapper
pred_wrapper <- function(data) {
  model <- model_timing_gates(
    distance = data$distance,
    time = data$time
  )

  params <- data.frame(t(coef(model)))

  predicted_time <- model$data$pred_time

  colnames(params) <- c(
    "est_MSS", "est_TAU", "est_MAC", "est_PMAX"
  )

  cbind(
    data,
    params,
    data.frame(predicted_time = as.numeric(predicted_time))
  )
}

# estimated parameters and predicted time
model_df <- sim_df %>%
  group_by(MSS, MAC, flying_start_distance) %>%
  do(pred_wrapper(.)) %>%
  ungroup()

# Prediction residuals
model_df$residuals <- model_df$time - model_df$predicted_time
```

```{r echo=FALSE}
# Estimates plot
plot_df <- model_df %>%
  group_by(MSS, MAC, flying_start_distance) %>%
  slice(1) %>%
  mutate(
    `MSS (m/s)` = est_MSS,
    `TAU (s)` = est_TAU,
    `MAC (m/s/s)` = est_MAC,
    `PMAX (W)` = est_PMAX
  ) %>%
  pivot_longer(cols = c("MSS (m/s)", "TAU (s)", "MAC (m/s/s)", "PMAX (W)")) %>%
  mutate(
    name = factor(name, levels = c("MSS (m/s)", "TAU (s)", "MAC (m/s/s)", "PMAX (W)"))
  )

ggplot(plot_df, aes(x = flying_start_distance, y = value)) +
  theme_bw(8) +
  geom_line(alpha = 0.7) +
  facet_wrap(~name, scales = "free_y") +
  xlab("Flying start distance (m)") +
  ylab("Estimated parameter")
```

As can be seen from the figure, MSS and TAU are underestimated, while MAC and PMAX are overestimated as the flying start distance increases.

Model residuals are also affected by the flying start distance. The shape of the distribution of the residuals depends on the number and splits utilized (e.g., 10, 20, 30, 40 $m$ versus 5, 15, 30 $m$). However, here we can see the effect of the flying start distance on the model residuals per split distance utilized in our simple simulation:

```{r echo=FALSE}
# Residuals
plot_df <- model_df %>%
  mutate(
    distance_string = paste0(distance, "m"),
    distance_string = factor(
      distance_string,
      levels = c("5m", "10m", "20m", "30m", "40m")
    )
  )

ggplot(
  plot_df,
  aes(
    y = residuals,
    x = flying_start_distance,
  )
) +
  theme_bw(8) +
  geom_line() +
  facet_wrap(~distance_string) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  xlab("Flying start distance (m)") +
  ylab("Observed time - predicted time (s)")
```

Another way to visualize the effect of the flying start distance on split distance residuals can be found in the following figure:

```{r echo=FALSE}
# Residuals
ggplot(
  model_df,
  aes(
    y = residuals,
    x = distance,
    color = flying_start_distance,
    group = flying_start_distance
  )
) +
  theme_bw(8) +
  geom_line(alpha = 0.3) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  scale_color_gradientn(colours = terrain.colors(5, rev = FALSE)) +
  xlab("Distance (m)") +
  ylab("Observed - predicted time (s)") +
  theme(legend.position = "top") +
  labs(color = "Flying start distance")
```

Any flying start with a difference between initial force production and start time can result in biased parameters and predictions. Since maximal sprint speed is difficult to improve, the effects of start inconsistencies can mask the effects of the training intervention. It is thus crucial to standardize the start when testing and implementing the following techniques when using the **{shorts}** package. 

## How to overcome missing the initial force production when using timing gates?

A potential solution is to use a correction factor - the recommendation in the literature is +0.5 $s$ [@haugenSprintMechanicalProperties2020; @haugenSprintMechanicalVariables2019]. Interestingly, the average difference between timing gates and a block start for 40 $m$ sprint time was 0.27 $s$ [@haugenDifferenceStartImpact2012]. So, while a timing correction factor is warranted to avoid subsequent errors in estimates of kinetic variables (e.g., overestimate power), a correction factor that is too large will have the opposite effect (e.g., underestimate power).  

Rather than providing *apriori* time correction from the literature, the **{shorts}** package provides an estimation of this parameter from the data provided, together with MSS and MAC. The same method is suggested by @stenrothForcevelocityProfilingIce2020, named the *time shift method*, and the estimated parameter is named the *time shift parameter*. We have named this parameter *time correction* (TC) to agree with the parameter introduced in the [Problems with time sync with the radar gun] section of this paper and the available literature. The model that implements the TC parameter is termed the *estimated TC model*.

When implementing time correction, equation \@ref(eq:time-distance) becomes:

\begin{equation}
  t(d) = TAU \times W(-e^{\frac{-d}{MSS \times TAU}} - 1) + \frac{d}{MSS} + TAU - TC (\#eq:time-correction)
\end{equation}

In **{shorts}** package, TC model is implemented in the `model_timing_gates_TC()` function. Here is how we can estimate Jack parameters using fixed time corrections (e.g., +0.3 and +0.5 $s$) or using estimated TC model:

```{r}
jack_profile_fixed_time_short <- model_timing_gates(
  distance = split_times$distance,
  time = split_times$jack_time + 0.3
)

jack_profile_fixed_time_long <- model_timing_gates(
  distance = split_times$distance,
  time = split_times$jack_time + 0.5
)

jack_profile_time_estimated <- model_timing_gates_TC(
  distance = split_times$distance,
  time = split_times$jack_time
)

jack_parameters <- full_join(
  rbind(
    data.frame(athlete = "John", t(coef(john_profile))),
    data.frame(athlete = "Jack - No corrections", t(coef(jack_profile))),
    data.frame(athlete = "Jack - Fixed TC (+0.3s)", t(coef(jack_profile_fixed_time_short))),
    data.frame(athlete = "Jack - Fixed TC (+0.5s)", t(coef(jack_profile_fixed_time_long)))
  ),
  data.frame(athlete = "Jack - Estimated TC", t(coef(jack_profile_time_estimated)))
)

kable(jack_parameters, digits = 2, booktabs = TRUE)
```

In Jack's case, both +0.3 $s$ fixed time correction and estimated TC model yield parameters closer to John's (i.e., *true* parameters). We have used these models in a retrospective pilot study [@vescoviSprintMechanicalCharacteristics2021], demonstrating statistically significant differences in estimated FVP parameters.

Instead of using time correction as a simple intercept in equation \@ref(eq:time-correction), we can estimate the *flying distance* (FD) using the following equation:

\begin{equation}
  \begin{split}
   t(d) &= (TAU \times W(-e^{\frac{-d + FD}{MSS \times TAU}} - 1) + \frac{d + FD}{MSS} + TAU) \\ 
   &\quad-(TAU \times W(-e^{\frac{FD}{MSS \times TAU}} - 1) + \frac{FD}{MSS} + TAU) 
   \end{split}
   (\#eq:distance-correction)
\end{equation}

We have named this model *estimated FD model*, and in the **{shorts}** package it is implemented in the `model_timing_gates_FD()` function. Here is how we can estimate Jack parameters using estimated FD model:

```{r}
jack_profile_FD <- model_timing_gates_FD(
  distance = split_times$distance,
  time = split_times$jack_time
)

jack_parameters <- full_join(
  jack_parameters,
  data.frame(athlete = "Jack - Estimated FD", t(coef(jack_profile_FD)))
)

kable(jack_parameters, digits = 2, booktabs = TRUE)
```

As can be seen from the results, the estimated FD model correctly estimated Jack's sprint parameters. There are a few issues with this model definition. Besides being novel and still not validated with actual data, the estimated FD model has three parameters to estimate, which implies that at least four sprint splits are needed. This imposes practical limitations since acquiring five timing gates (one for a start and four for splits) might be practically troublesome (which is also the case with the estimated TC model). In addition, the estimated FD model can be ill-defined in scenarios involving reaction time and no actual flying sprint involved. This is often the case when a gunshot is used to initiate the timing system.

### Simple simulation using proposed models

In this section, we examine how these models (no correction, fixed time correction, estimated TC, and estimated FD) perform using simulated data with varying flying start distances (please refer to the [Supplemental Material] for the R code), assuming *true* MSS equal to 9 $ms^{-1}$, and MAC equal to 8 $ms^{-2}$ (i.e., sprint characteristics of Jack and John). Timing gates are set at 5, 10, 20, 30, and 40 $m$. 

```{r echo=FALSE}
pred_wrapper <- function(data) {
  merge_model <- function(data, model, model_name) {
    data$model <- model_name
    data$est_MSS <- model$parameters$MSS
    data$est_TAU <- model$parameters$TAU
    data$est_MAC <- model$parameters$MAC
    data$est_PMAX <- model$parameters$PMAX
    data$predicted_time <- model$data$pred_time
    data$residuals <- model$data$time - data$predicted_time

    data
  }

  no_correction <- model_timing_gates(
    distance = data$distance,
    time = data$time
  )

  fixed_correction_short <- model_timing_gates(
    distance = data$distance,
    time = data$time + 0.3
  )

  fixed_correction_long <- model_timing_gates(
    distance = data$distance,
    time = data$time + 0.5
  )

  time_correction <- model_timing_gates_TC(
    distance = data$distance,
    time = data$time
  )

  distance_correction <- model_timing_gates_FD(
    distance = data$distance,
    time = data$time
  )

  rbind(
    merge_model(
      data,
      no_correction,
      "No correction"
    ),
    merge_model(
      data,
      fixed_correction_short,
      "Fixed TC +0.3s"
    ),
    merge_model(
      data,
      fixed_correction_long,
      "Fixed TC +0.5s"
    ),
    merge_model(
      data,
      time_correction,
      "Estimated TC"
    ),
    merge_model(
      data,
      distance_correction,
      "Estimated FD"
    )
  )
}

# estimated parameters and predicted time
model_df <- sim_df %>%
  filter(flying_start_distance > 0) %>%
  group_by(MSS, MAC, flying_start_distance) %>%
  do(pred_wrapper(.)) %>%
  ungroup()
```

As can be seen from the following figure, the estimated TC model estimates sprint parameters with increasing bias as the flying distance increases. In contrast, the estimated FD model estimates sprint parameters perfectly. If correct TC is not applied, fixed time correction models have a much larger bias. This value depends on sprint characteristics, the flying distance, and timing gate splits. It is thus impossible to provide a single fixed time correction value that will serve its corrective purpose across different scenarios and athletes measured. 

```{r echo=FALSE}
model_df$model <- factor(
  model_df$model,
  levels = c(
    "No correction",
    "Fixed TC +0.3s",
    "Fixed TC +0.5s",
    "Estimated TC",
    "Estimated FD"
  )
)

# Estimates plot
plot_df <- model_df %>%
  group_by(model, MSS, MAC, flying_start_distance) %>%
  slice(1) %>%
  mutate(
    `MSS (m/s)` = est_MSS,
    `TAU (s)` = est_TAU,
    `MAC (m/s/s)` = est_MAC,
    `PMAX (W)` = est_PMAX
  ) %>%
  pivot_longer(cols = c("MSS (m/s)", "TAU (s)", "MAC (m/s/s)", "PMAX (W)")) %>%
  mutate(
    name = factor(name, levels = c("MSS (m/s)", "TAU (s)", "MAC (m/s/s)", "PMAX (W)"))
  )

ggplot(plot_df, aes(x = flying_start_distance, y = value, group = model, color = model)) +
  theme_bw(8) +
  geom_line(alpha = 0.7) +
  facet_wrap(~name, scales = "free_y") +
  xlab("Flying start distance (m)") +
  ylab("Estimated parameter") +
  theme(
    legend.title = element_blank(),
    legend.position = "top"
  )
```

The following figure depicts residuals across split distances for each simulated flying start distance. As can be seen, estimated TC and FD models perform much better than the no correction and fixed time correction models. 

```{r echo=FALSE}
# Residuals
ggplot(
  model_df,
  aes(
    y = residuals,
    x = distance,
    color = flying_start_distance,
    group = flying_start_distance
  )
) +
  theme_bw(8) +
  geom_line(alpha = 0.3) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  scale_color_gradientn(colours = terrain.colors(5, rev = FALSE)) +
  facet_wrap(~model) +
  xlab("Distance (m)") +
  ylab("Observed - predicted time (s)") +
  theme(legend.position = "top") +
  labs(color = "Flying start distance")
```

The results of this simple simulation demonstrate that the estimated TC and FD models represent sound improvements in parameter estimation and model fit compared to the no corrections model and fixed TC models when attempting to overcome the flying start issues. A more detailed simulation study is ongoing, and the results will be reported in another paper.

# Cross-Validation

To estimate parameter stability, model over-fitting, and performance on unseen data, **{shorts}** model functions come with implemented *leave-one-out cross-validation* (LOOCV) for the timing gates models and *n-fold cross-validation* (CV) for the radar gun models [@jamesIntroductionStatisticalLearning2017; @jovanovicBmbstatsBootstrapMagnitudebased2020; @kuhnAppliedPredictiveModeling2018]. LOOCV involves a simple yet powerful procedure of removing each observation, rebuilding the model, and making predictions for that removed observation. This process is repeated for each observation in the model dataset. LOOCV allows one to check estimated parameters' stability and model performance on unseen data.

Let's perform LOOCV using Jack's data and the estimated TC model:

```{r}
jack_LOOCV <- model_timing_gates_TC(
  distance = split_times$distance,
  time = split_times$jack_time,
  LOOCV = TRUE
)
```

The model print output provides training dataset estimates and model performance, as well as LOOCV estimates and model performance. 

Next, we plot estimated parameters across LOOCV folds (please refer to the [Supplemental Material] for the R code):

```{r echo=FALSE}
df <- jack_LOOCV$CV$parameters

df <- pivot_longer(df, cols = 1:5, names_to = "parameter")

df$parameter <- factor(
  df$parameter,
  levels = c(
    "MSS",
    "TAU",
    "MAC",
    "PMAX",
    "FD"
  )
)

ggplot(df, aes(x = value)) +
  theme_bw(8) +
  geom_boxplot() +
  facet_wrap(~parameter, scales = "free_x") +
  xlab(NULL) +
  ylab(NULL) +
  theme(
    axis.ticks.y = element_blank(),
    axis.text.y = element_blank()
  )
```

Here is the plot of the training and LOOCV residuals:

```{r echo=FALSE}
df <- data.frame(
  distance = jack_LOOCV$data$distance,
  time = jack_LOOCV$data$time,
  pred_time = jack_LOOCV$data$pred_time,
  LOOCV_time = jack_LOOCV$CV$data$pred_time
)

df <- df %>%
  pivot_longer(cols = c("pred_time", "LOOCV_time"))

df$resid <- df$value - df$time

ggplot(df, aes(x = distance, y = resid, color = name)) +
  theme_bw(8) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_point() +
  theme(legend.title = element_blank()) +
  xlab("Distance (m)") +
  ylab("Observed - predicted time (s)") +
  theme(
    legend.title = element_blank(),
    legend.position = "top"
  )
```

As expected, the model has more issues predicting unseen split times for short or long distances. Please note that since LOOCV removes one observation, if the model estimates three parameters, then at least five observations are needed since we need to ensure the model can be estimated once a single observation is removed.

Since there are much more observations in the radar gun data, n-fold CV is implemented instead of LOOCV. CV procedure randomly splits the dataset into n-folds, leave one fold-out for prediction, and makes a model using the remaining folds. This is then repeated for all the folds. 

```{r}
# Estimate John's MSS, TAU, MAC, and PMAX
m2_CV <- model_radar_gun(
  velocity = john_RG_data$velocity,
  time = john_RG_data$time,
  # Eneter number of folds
  CV = 10
)

# Estimated parameters for each fold
m2_CV$CV$parameters
```

# Example analysis

Let us use real-world data to demonstrate the functionalities of the **{shorts}** package. We will use the dataset from Usain Bolt's performance at the IAAF World Championship finals in London, 2017.

Since reaction time enters the splits, we want to see how that will affect the model estimates, mainly if the estimated time correction model will pick up reaction time.

For the sake of this analysis, only 10 $m$ splits over 60 $m$ race distance are used. 

```{r}
bolt_reaction_time <- 0.183

bolt_distance <- c(10, 20, 30, 40, 50, 60)
bolt_time <- c(1.963, 2.983, 3.883, 4.763, 5.643, 6.493)

# No corrections model
bolt_m1 <- model_timing_gates(
  distance = bolt_distance,
  time = bolt_time
)

# Model with reaction time as fixed time correction
bolt_m2 <- model_timing_gates(
  distance = bolt_distance,
  time = bolt_time - bolt_reaction_time
)

# Model with estimated time correction
bolt_m3 <- model_timing_gates_TC(
  distance = bolt_distance,
  time = bolt_time
)

# Model with flying distance correction
# THIS CANNOT BE ESTIMATED SINCE IT IS ILL-DEFINED MODEL
# bolt_m4 <- model_timing_gates_FD(
#   distance = bolt_distance,
#   time = bolt_time
# )


bolt_model <- full_join(
  rbind(
    data.frame(model = "No correction", t(coef(bolt_m1))),
    data.frame(model = "No correction - RT", t(coef(bolt_m2)))
  ),
  data.frame(model = "Estimated TC", t(coef(bolt_m3)))
)

kable(bolt_model, digits = 2, booktabs = TRUE)
```

Here is the model estimate of the time and distance it takes for Bolt to reach 99% of MSS. These estimated times and distances represent *true* time and distance when the sprint is initiated at $t=0$ $s$ and $d=0$ $m$. 

```{r}
bolt_model <- bolt_model %>%
  group_by(model) %>%
  mutate(
    `99% MSS (m)` = find_velocity_critical_distance(
      MSS = MSS, MAC = MAC,
      percent = 0.99
    ),
    `99% MSS (s)` = find_velocity_critical_time(
      MSS = MSS, MAC = MAC,
      percent = 0.99
    )
  )

kable(bolt_model[c(1, 7, 8)], digits = 2, booktabs = TRUE)
```

# Conclusion

Which model should be used? Although providing novel theoretical models in this paper, we acknowledge the need for validating them in practice against gold-standard methods, assessing their agreement, and their power in detecting and adjusting for timing inconsistencies. A more thorough theoretical simulation study is currently in development, intending to explore the behavior of these models under different scenarios.

We hope that the **{shorts}** package will help fellow sports scientists and coaches explore short sprint profiles and help in driving research, particularly in devising measuring protocols that are sensitive enough to capture training intervention changes but also robust enough to take into account potential sprint initiation and timing inconsistencies.  
```{r include=FALSE}
# Return original options
options(op)
```

# Supplemental Material

The *R Markdown* [@R-bookdown; @R-rmarkdown; @rmarkdown2018; @rmarkdown2020] source code for the paper can be found on the GitHub repository: [https://github.com/mladenjovanovic/shorts-paper](https://github.com/mladenjovanovic/shorts-paper). 

# References
